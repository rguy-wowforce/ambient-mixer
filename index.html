<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ambient + ElevenLabs Voice Mixer</title>
  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121824;
      --text: #e7edf5;
      --muted: #9db1c7;
      --accent: #4ea1ff;
      --accent-2: #7bffb1;
    }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 10%, #0f1522, #0b0f14) fixed; color: var(--text);
      display: grid; place-items: center;
    }
    .card {
      width: min(960px, 92vw);
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 18px; padding: 24px; box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    h1 { font-size: 1.35rem; margin: 0 0 4px; letter-spacing: 0.2px; }
    p { margin: 0.5rem 0 1rem; color: var(--muted); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; }
    .panel { background: var(--panel); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 16px; }
    .panel h2 { font-size: 1rem; margin: 0 0 10px; color: var(--accent); }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .controls button {
      background: linear-gradient(180deg, #1e293b, #0f172a);
      color: #e6f0ff; border: 1px solid rgba(255,255,255,0.12); border-radius: 999px; padding: 10px 14px; cursor: pointer;
    }
    .controls button:hover { filter: brightness(1.1); }
    .slider { width: 220px; }
    .row-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; margin-top: 14px; }
    .hint { font-size: 0.9rem; color: var(--muted); }
    .small { font-size: 0.85rem; opacity: 0.9; }
    .grid { display: grid; gap: 10px; }
    label { font-size: 0.9rem; color: var(--muted); }
    input[type="file"]::file-selector-button {
      border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 8px 10px; margin-right: 10px; background: #0f172a; color: #d8e7ff; cursor: pointer;
    }
    .badge { padding: 2px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); color: #cfe6ff; }
    .stack { display: grid; gap: 8px; }
    .spacer { height: 6px; }
    .row-1 { display: grid; grid-template-columns: 1fr auto; gap: 18px; align-items: center; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.85rem; color: #cbe0ff; }
  </style>
</head>
<body>
  <div class="card">
    <div class="row-1">
      <div>
        <h1>Ambient + ElevenLabs Voice Mixer</h1>
        <p>Plays your agent’s voice with a looping ambient bed. Drop in <span class="badge">voice.mp3</span> and <span class="badge">ambient.mp3</span> or pick files below. Volumes persist locally.</p>
      </div>
      <div class="mono" id="status">stopped</div>
    </div>

    <div class="controls" style="margin: 12px 0 18px; flex-wrap: wrap;">
      <button id="btnPlay">▶︎ Play</button>
      <button id="btnPause">⏸︎ Pause</button>
      <button id="btnStop">■ Stop</button>
      <span class="hint">First tap may be needed on mobile due to autoplay policies.</span>
    </div>

    <!-- URL loaders -->
    <div class="panel" style="margin-bottom:14px;">
      <h2>Load by URL (optional)</h2>
      <div class="grid">
        <label>Voice URL</label>
        <input id="voiceUrl" type="url" placeholder="https://…/voice.mp3" />
        <label>Ambient URL</label>
        <input id="ambUrl" type="url" placeholder="https://…/ambient.mp3" />
        <div class="controls">
          <button id="btnLoadUrls">Load URLs</button>
          <span class="hint">Tip: you can also pass <span class="mono">?voice=…&ambient=…</span> as query params.</span>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="panel">
        <h2>ElevenLabs Voice</h2>
        <div class="grid">
          <label>Pick or drop a file (e.g., <code>voice.mp3</code>)</label>
          <input id="voiceFile" type="file" accept="audio/*" />
          <div class="controls">
            <label>Voice volume</label>
            <input id="voiceVol" class="slider" type="range" min="0" max="1" step="0.01" />
            <span id="voiceVolOut" class="small"></span>
          </div>
          <div class="controls">
            <label>Playback</label>
            <select id="voiceMode">
              <option value="once">Play once</option>
              <option value="loop">Loop</option>
            </select>
          </div>
        </div>
      </div>

      <div class="panel">
        <h2>Ambient Bed</h2>
        <div class="grid">
          <label>Pick or drop a file (e.g., <code>ambient.mp3</code>)</label>
          <input id="ambFile" type="file" accept="audio/*" />
          <div class="controls">
            <label>Ambient volume</label>
            <input id="ambVol" class="slider" type="range" min="0" max="1" step="0.01" />
            <span id="ambVolOut" class="small"></span>
          </div>
          <div class="controls">
            <label>Loop ambient</label>
            <input id="ambLoop" type="checkbox" checked />
          </div>
        </div>
      </div>
    </div>

    <div class="row-2">
      <div class="panel">
        <h2>Quick Tips</h2>
        <ul class="small">
          <li>Name your files <code>voice.mp3</code> and <code>ambient.mp3</code> to auto-load from the same folder.</li>
          <li>Keep ambient around −20 to −30 dB relative to voice for subtlety.</li>
          <li>Use <em>Loop</em> for ambient; voice usually <em>Play once</em>.</li>
        </ul>
      </div>
      <div class="panel">
        <h2>Integrating with ElevenLabs</h2>
        <p class="small">Point your agent to save generated audio as <code>voice.mp3</code> in this directory (via your pipeline or CI). Ambient can be any loopable bed; replace <code>ambient.mp3</code> whenever you like.</p>
      </div>
    </div>

    <!-- Hidden audio elements used as sources -->
    <audio id="voice" crossorigin="anonymous"></audio>
    <audio id="ambient" crossorigin="anonymous" loop></audio>
  </div>

  <script>
    const els = {
      voice: document.getElementById('voice'),
      ambient: document.getElementById('ambient'),
      voiceFile: document.getElementById('voiceFile'),
      ambFile: document.getElementById('ambFile'),
      voiceVol: document.getElementById('voiceVol'),
      ambVol: document.getElementById('ambVol'),
      voiceVolOut: document.getElementById('voiceVolOut'),
      ambVolOut: document.getElementById('ambVolOut'),
      voiceMode: document.getElementById('voiceMode'),
      ambLoop: document.getElementById('ambLoop'),
      btnPlay: document.getElementById('btnPlay'),
      btnPause: document.getElementById('btnPause'),
      btnStop: document.getElementById('btnStop'),
      status: document.getElementById('status'),
      voiceUrl: document.getElementById('voiceUrl'),
      ambUrl: document.getElementById('ambUrl'),
      btnLoadUrls: document.getElementById('btnLoadUrls'),
    };

    // Persisted settings
    const get = (k, d) => { try { const v = localStorage.getItem(k); return v==null? d : JSON.parse(v); } catch { return d; } };
    const set = (k, v) => { try { localStorage.setItem(k, JSON.stringify(v)); } catch {} };

    // Defaults
    els.voiceVol.value = get('voiceVol', 0.9);
    els.ambVol.value = get('ambVol', 0.25);
    els.voiceMode.value = get('voiceMode', 'once');
    els.ambLoop.checked = get('ambLoop', true);
    syncVolLabels();

    // Try autoload local files if present in same directory
    fetch('voice.mp3', { method: 'HEAD' }).then(r => { if (r.ok && !els.voice.src) els.voice.src = 'voice.mp3'; });
    fetch('ambient.mp3', { method: 'HEAD' }).then(r => { if (r.ok && !els.ambient.src) els.ambient.src = 'ambient.mp3'; });

    // Load from URL query params if provided (?voice=…&ambient=…)
    const qp = new URLSearchParams(location.search);
    const voiceQP = qp.get('voice');
    const ambQP = qp.get('ambient');
    if (voiceQP) { els.voice.src = voiceQP; els.voiceUrl && (els.voiceUrl.value = voiceQP); }
    if (ambQP) { els.ambient.src = ambQP; els.ambUrl && (els.ambUrl.value = ambQP); }; });
    fetch('ambient.mp3', { method: 'HEAD' }).then(r => { if (r.ok) els.ambient.src = 'ambient.mp3'; });

    // File pickers
    els.voiceFile.addEventListener('change', e => {
      const f = e.target.files?.[0];
      if (f) { els.voice.src = URL.createObjectURL(f); console.log('Loaded voice file:', f.name); }
    });
    els.ambFile.addEventListener('change', e => {
      const f = e.target.files?.[0];
      if (f) { els.ambient.src = URL.createObjectURL(f); console.log('Loaded ambient file:', f.name); }
    });

    // Manual URL loader
    if (els.btnLoadUrls) {
      els.btnLoadUrls.addEventListener('click', () => {
        const v = (els.voiceUrl?.value || '').trim();
        const a = (els.ambUrl?.value || '').trim();
        if (v) els.voice.src = v;
        if (a) els.ambient.src = a;
        updateStatus();
      });
    }

    // Audio graph
    let ctx, voiceNode, ambNode, voiceGain, ambGain;
    function ensureCtx() {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        voiceNode = ctx.createMediaElementSource(els.voice);
        ambNode = ctx.createMediaElementSource(els.ambient);
        voiceGain = ctx.createGain();
        ambGain = ctx.createGain();
        voiceNode.connect(voiceGain).connect(ctx.destination);
        ambNode.connect(ambGain).connect(ctx.destination);
        applyGains();
      }
      return ctx;
    }

    function applyGains() {
      if (!voiceGain || !ambGain) return;
      const v = clamp(parseFloat(els.voiceVol.value), 0, 1);
      const a = clamp(parseFloat(els.ambVol.value), 0, 1);
      smoothSet(voiceGain.gain, v);
      smoothSet(ambGain.gain, a);
      syncVolLabels();
    }

    function smoothSet(param, value) {
      const t = ctx?.currentTime || 0;
      param.cancelScheduledValues(t);
      param.setValueAtTime(param.value, t);
      param.linearRampToValueAtTime(value, t + 0.05);
    }

    function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

    function syncVolLabels() {
      els.voiceVolOut.textContent = Math.round(els.voiceVol.value * 100) + '%';
      els.ambVolOut.textContent = Math.round(els.ambVol.value * 100) + '%';
    }

    // Loop toggles & mode
    function syncModes() {
      els.ambient.loop = !!els.ambLoop.checked;
      els.voice.loop = els.voiceMode.value === 'loop';
    }

    // Transport controls
    async function playAll() {
      ensureCtx();
      syncModes();
      applyGains();
      try { await ctx.resume(); } catch {}
      // Start ambient first for bed
      if (els.ambient.src) {
        if (els.ambient.paused) {
          try { await els.ambient.play(); } catch {}
        }
      }
      // Start voice after small offset to avoid click
      if (els.voice.src) {
        setTimeout(async () => {
          if (els.voice.paused) { try { await els.voice.play(); } catch {} }
        }, 80);
      }
      updateStatus();
    }

    function pauseAll() {
      els.voice.pause();
      els.ambient.pause();
      updateStatus();
    }

    function stopAll() {
      els.voice.pause(); els.voice.currentTime = 0;
      els.ambient.pause(); els.ambient.currentTime = 0;
      updateStatus();
    }

    function updateStatus() {
      const v = els.voice.paused ? 'paused' : 'playing';
      const a = els.ambient.paused ? 'paused' : 'playing';
      els.status.textContent = `voice: ${v} | ambient: ${a}`;
    }

    // Persist UI changes
    els.voiceVol.addEventListener('input', () => { set('voiceVol', els.voiceVol.value); applyGains(); });
    els.ambVol.addEventListener('input', () => { set('ambVol', els.ambVol.value); applyGains(); });
    els.voiceMode.addEventListener('change', () => { set('voiceMode', els.voiceMode.value); syncModes(); });
    els.ambLoop.addEventListener('change', () => { set('ambLoop', els.ambLoop.checked); syncModes(); });

    // Buttons
    els.btnPlay.addEventListener('click', playAll);
    els.btnPause.addEventListener('click', pauseAll);
    els.btnStop.addEventListener('click', stopAll);

    // Mobile/Autoplay unlock: resume context on first user gesture
    const unlock = () => { if (ctx?.state === 'suspended') ctx.resume(); window.removeEventListener('touchstart', unlock); window.removeEventListener('click', unlock); };
    window.addEventListener('touchstart', unlock, { once: true });
    window.addEventListener('click', unlock, { once: true });

    // Keep status in sync with element events
    ['play','pause','ended'].forEach(ev => {
      els.voice.addEventListener(ev, updateStatus);
      els.ambient.addEventListener(ev, updateStatus);
    });

    // Drag-and-drop support
    document.addEventListener('dragover', e => { e.preventDefault(); });
    document.addEventListener('drop', e => {
      e.preventDefault();
      const files = Array.from(e.dataTransfer.files || []);
      for (const f of files) {
        if (f.type.startsWith('audio/')) {
          if (!els.voice.src) { els.voice.src = URL.createObjectURL(f); }
          else { els.ambient.src = URL.createObjectURL(f); }
        }
      }
    });
  </script>
</body>
</html>
